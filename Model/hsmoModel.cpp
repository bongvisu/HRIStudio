#include "hsmoPrecompiled.h"
#include "hsmoModel.h"
#include "hsmoHriBlock.h"
#include "hsmoCustomCommand.h"
#include <xscPathUtil.h>

using namespace std;
using namespace xsc;

namespace hsmo {

const wchar_t* Model::FILE_EXTENSION = L".hsproject";

XSC_IMPLEMENT_DYNAMIC(hsmo, Model, Level)

Model::Model(const std::wstring& path)
{
	mFilePath = path;

	PathUtil::SplitToDirectoryAndName(path, mDirectory, mName);
	if (*mDirectory.rbegin() != L'\\')
	{
		mDirectory += L'\\';
	}
}

Model::~Model()
{
}

void Model::GetHierarchicalPath(wstring& path) const
{
	path = mName;
}

Component* Model::GetModel() const
{
	return const_cast<Model*>(this);
}

const wstring& Model::GetDirectory() const
{
	return mDirectory;
}

void Model::ExecuteCommand(const CommandPtr& command)
{
	if (command->Exec())
	{
		mUndoStack.push_back(command);
		if (mUndoStack.size() > 100)
		{
			mUndoStack.pop_front();
		}

		mRedoStack.clear();
	}
}

void Model::EnrollCustomCommand(Command* command)
{
	CommandPtr ptr(command);
	mUndoStack.push_back(ptr);
	if (mUndoStack.size() > 100)
	{
		mUndoStack.pop_front();
	}

	mRedoStack.clear();
}

void Model::Undo()
{
	if (mUndoStack.size())
	{
		const auto& command = mUndoStack.back();
		command->Undo();

		mRedoStack.push_back(command);
		if (mRedoStack.size() > 100)
		{
			mRedoStack.pop_front();
		}
		
		mUndoStack.pop_back();
	}
}

void Model::Redo()
{
	if (mRedoStack.size())
	{
		const auto& command = mRedoStack.back();
		command->Redo();

		mUndoStack.push_back(command);
		if (mUndoStack.size() > 100)
		{
			mUndoStack.pop_front();
		}

		mRedoStack.pop_back();
	}
}

void Model::SortOutPerContext(const ComponentSet& components, ModelToComponentSet& modelToComponentSet)
{
	ModelToComponentSet::iterator iter;
	for (auto component : components)
	{
		auto model = static_cast<Model*>(component->GetModel());
		iter = modelToComponentSet.find(model);
		if (iter == modelToComponentSet.end())
		{
			ComponentSet children;
			children.insert(component);
			modelToComponentSet[model] = std::move(children);
		}
		else
		{
			iter->second.insert(component);
		}
	}
}

const wstring& Model::GetFilePath() const
{
	return mFilePath;
}

bool Model::Compile(wstring& code)
{
	SYSTEMTIME systemtime;
	GetLocalTime(&systemtime);
	swprintf_s(msGenericTextBuf,
		L"///////////////////////////////////////////////////////////////////////////////////////////////////////\n"
		L"//----------------------- Autogenerated by HRI Studio at "
		L"%04u-%02u-%02u  %02u:%02u:%02u -----------------------//\n"
		L"///////////////////////////////////////////////////////////////////////////////////////////////////////\n",
		systemtime.wYear,
		systemtime.wMonth,
		systemtime.wDay,
		systemtime.wHour,
		systemtime.wMinute,
		systemtime.wSecond);

	code = msGenericTextBuf;

	for (auto block : mBlocks)
	{
		auto hriBlock = static_cast<HriBlock*>(block);
		if (false == hriBlock->GenerateCode(code, 0))
		{
			code = L"\n/* Code Generation Failed */\n";
			return false;
		}
	}

	return true;
}

// Stream -------------------------------------------------------------------------------------------------------------
bool Model::Load()
{
	Stream stream;
	if (false == stream.Load(mFilePath.c_str()))
	{
		return false;
	}
	return Deserialize(stream);
}

bool Model::Save()
{
	Stream stream;
	if (Serialize(stream))
	{
		return stream.Save(mFilePath.c_str());
	}
	return false;
}

bool Model::Serialize(Stream& stream)
{
	stream.BeginOutputSection(L"Model", false, false);
	
	bool result = Level::Serialize(stream);

	stream.EndOutputSection(true, false);

	return result;
}

bool Model::Deserialize(Stream& stream)
{
	int numElements = stream.BeginInputSection(L"Model");
	if (numElements != 1)
	{
		stream.EndInputSection();
		return false;
	}

	stream.ActivateItem(0);
	bool result = Level::Deserialize(stream);
	stream.DeactivateItem();

	stream.EndInputSection();

	if (result)
	{
		return DoPostloadProcessing(stream);
	}
	return false;
}
// --------------------------------------------------------------------------------------------------------------------

} // namespace hsmo
